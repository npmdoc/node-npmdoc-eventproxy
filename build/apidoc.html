<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/JacksonTian/eventproxy"

    >eventproxy (v0.3.5)</a>
</h1>
<h4>An implementation of task/event based asynchronous pattern.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.eventproxy">module eventproxy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.eventproxy">
            function <span class="apidocSignatureSpan"></span>eventproxy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy">
            function <span class="apidocSignatureSpan">eventproxy.</span>EventProxy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.create">
            function <span class="apidocSignatureSpan">eventproxy.</span>create
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">eventproxy.</span>EventProxy.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eventproxy.EventProxy">module eventproxy.EventProxy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.EventProxy">
            function <span class="apidocSignatureSpan">eventproxy.</span>EventProxy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.create">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.</span>create
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eventproxy.EventProxy.prototype">module eventproxy.EventProxy.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.addListener">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>addListener
            <span class="apidocSignatureSpan">(ev, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.after">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>after
            <span class="apidocSignatureSpan">(eventname, times, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.all">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>all
            <span class="apidocSignatureSpan">(eventname1, eventname2, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.any">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>any
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.asap">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>asap
            <span class="apidocSignatureSpan">(ev, callback, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.assign">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>assign
            <span class="apidocSignatureSpan">(eventname1, eventname2, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.assignAll">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>assignAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.assignAlways">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>assignAlways
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.bind">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>bind
            <span class="apidocSignatureSpan">(ev, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.bindForAll">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>bindForAll
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.done">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>done
            <span class="apidocSignatureSpan">(handler, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.doneLater">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>doneLater
            <span class="apidocSignatureSpan">(handler, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.emit">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>emit
            <span class="apidocSignatureSpan">(eventname, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.emitLater">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>emitLater
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.fail">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>fail
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.fire">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>fire
            <span class="apidocSignatureSpan">(eventname, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.group">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>group
            <span class="apidocSignatureSpan">(eventname, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.headbind">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>headbind
            <span class="apidocSignatureSpan">(ev, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.immediate">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>immediate
            <span class="apidocSignatureSpan">(ev, callback, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.not">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>not
            <span class="apidocSignatureSpan">(eventname, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.on">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>on
            <span class="apidocSignatureSpan">(ev, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.once">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>once
            <span class="apidocSignatureSpan">(ev, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.removeAllListeners">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>removeAllListeners
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.removeListener">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>removeListener
            <span class="apidocSignatureSpan">(eventname, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.subscribe">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>subscribe
            <span class="apidocSignatureSpan">(ev, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.tail">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>tail
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.throw">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>throw
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.trigger">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>trigger
            <span class="apidocSignatureSpan">(eventname, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.unbind">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>unbind
            <span class="apidocSignatureSpan">(eventname, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventproxy.EventProxy.prototype.unbindForAll">
            function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>unbindForAll
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eventproxy" id="apidoc.module.eventproxy">module eventproxy</a></h1>


    <h2>
        <a href="#apidoc.element.eventproxy.eventproxy" id="apidoc.element.eventproxy.eventproxy">
        function <span class="apidocSignatureSpan"></span>eventproxy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eventproxy = function () {
  if (!(this instanceof EventProxy)) {
    return new EventProxy();
  }
  this._callbacks = {};
  this._fired = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy" id="apidoc.element.eventproxy.EventProxy">
        function <span class="apidocSignatureSpan">eventproxy.</span>EventProxy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">EventProxy = function () {
  if (!(this instanceof EventProxy)) {
    return new EventProxy();
  }
  this._callbacks = {};
  this._fired = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.create" id="apidoc.element.eventproxy.create">
        function <span class="apidocSignatureSpan">eventproxy.</span>create
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function () {
  var ep = new EventProxy();
  var args = CONCAT.apply([], arguments);
  if (args.length) {
    var errorHandler = args[args.length - 1];
    var callback = args[args.length - 2];
    if (typeof errorHandler === &#x27;function&#x27; &#x26;&#x26; typeof callback === &#x27;function&#x27;) {
      args.pop();
      ep.fail(errorHandler);
    }
    ep.assign.apply(ep, args);
  }
  return ep;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
4. 友好的Error handling
5. 无平台依赖，适合前后端，能用于浏览器和Node.js
6. 兼容CMD，AMD以及CommonJS模块环境

现在的，无深度嵌套的，并行的

```js
var ep = EventProxy.<span class="apidocCodeKeywordSpan">create</span>(&#x22;template&#x22;, &#x22;data&#x22;, &#x22;l10n&#x22;,
function (template, data, l10n) {
  _.template(template, data, l10n);
});

$.get(&#x22;template&#x22;, function (template) {
  // something
  ep.emit(&#x22;template&#x22;, template);
});
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eventproxy.EventProxy" id="apidoc.module.eventproxy.EventProxy">module eventproxy.EventProxy</a></h1>


    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.EventProxy" id="apidoc.element.eventproxy.EventProxy.EventProxy">
        function <span class="apidocSignatureSpan">eventproxy.</span>EventProxy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">EventProxy = function () {
  if (!(this instanceof EventProxy)) {
    return new EventProxy();
  }
  this._callbacks = {};
  this._fired = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.create" id="apidoc.element.eventproxy.EventProxy.create">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.</span>create
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function () {
  var ep = new EventProxy();
  var args = CONCAT.apply([], arguments);
  if (args.length) {
    var errorHandler = args[args.length - 1];
    var callback = args[args.length - 2];
    if (typeof errorHandler === &#x27;function&#x27; &#x26;&#x26; typeof callback === &#x27;function&#x27;) {
      args.pop();
      ep.fail(errorHandler);
    }
    ep.assign.apply(ep, args);
  }
  return ep;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
4. 友好的Error handling
5. 无平台依赖，适合前后端，能用于浏览器和Node.js
6. 兼容CMD，AMD以及CommonJS模块环境

现在的，无深度嵌套的，并行的

```js
var ep = EventProxy.<span class="apidocCodeKeywordSpan">create</span>(&#x22;template&#x22;, &#x22;data&#x22;, &#x22;l10n&#x22;,
function (template, data, l10n) {
  _.template(template, data, l10n);
});

$.get(&#x22;template&#x22;, function (template) {
  // something
  ep.emit(&#x22;template&#x22;, template);
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eventproxy.EventProxy.prototype" id="apidoc.module.eventproxy.EventProxy.prototype">module eventproxy.EventProxy.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.addListener" id="apidoc.element.eventproxy.EventProxy.prototype.addListener">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>addListener
        <span class="apidocSignatureSpan">(ev, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addListener = function (ev, callback) {
  debug(&#x27;Add listener for %s&#x27;, ev);
  this._callbacks[ev] = this._callbacks[ev] || [];
  this._callbacks[ev].push(callback);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Bind an event, specified by a string name, `ev`, to a `callback` function.
 * Passing __ALL_EVENT__ will bind the callback to all events fired.
* Examples:
 * ```js
 * var proxy = new EventProxy();
 * proxy.<span class="apidocCodeKeywordSpan">addListener</span>(&#x22;template&#x22;, function (event) {
 *   // TODO
 * });
 * ```
 * @param {String} eventname Event name.
 * @param {Function} callback Callback.
 */
EventProxy.prototype.addListener = function (ev, callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.after" id="apidoc.element.eventproxy.EventProxy.prototype.after">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>after
        <span class="apidocSignatureSpan">(eventname, times, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">after = function (eventname, times, callback) {
  if (times === 0) {
    callback.call(null, []);
    return this;
  }
  var proxy = this,
    firedData = [];
  this._after = this._after || {};
  var group = eventname + &#x27;_group&#x27;;
  this._after[group] = {
    index: 0,
    results: []
  };
  debug(&#x27;After emit %s times, event %s\&#x27;s listenner will execute&#x27;, times, eventname);
  var all = function (name, data) {
    if (name === eventname) {
      times--;
      firedData.push(data);
      if (times &#x3c; 1) {
        debug(&#x27;Event %s was emit %s, and execute the listenner&#x27;, eventname, times);
        proxy.unbindForAll(all);
        callback.apply(null, [firedData]);
      }
    }
    if (name === group) {
      times--;
      proxy._after[group].results[data.index] = data.result;
      if (times &#x3c; 1) {
        debug(&#x27;Event %s was emit %s, and execute the listenner&#x27;, eventname, times);
        proxy.unbindForAll(all);
        callback.call(null, proxy._after[group].results);
      }
    }
  };
  proxy.bindForAll(all);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

### 重复异步协作
此处以读取目录下的所有文件为例，在异步操作中，我们需要在所有异步调用结束后，执行某些操作。

```js
var ep = new EventProxy();
ep.<span class="apidocCodeKeywordSpan">after</span>(&#x27;got_file&#x27;, files.length, function (list) {
// 在所有文件的异步执行结束后将被执行
// 所有文件的内容都存在list数组中
});
for (var i = 0; i &#x3c; files.length; i++) {
fs.readFile(files[i], &#x27;utf-8&#x27;, function (err, content) {
  // 触发结果事件
  ep.emit(&#x27;got_file&#x27;, content);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.all" id="apidoc.element.eventproxy.EventProxy.prototype.all">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>all
        <span class="apidocSignatureSpan">(eventname1, eventname2, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">all = function (eventname1, eventname2, callback) {
  var args = CONCAT.apply([], arguments);
  args.push(true);
  _assign.apply(this, args);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```
## 异步协作
### 多类型异步协作
此处以页面渲染为场景，渲染页面需要模板、数据。假设都需要异步读取。

```js
var ep = new EventProxy();
ep.<span class="apidocCodeKeywordSpan">all</span>(&#x27;tpl&#x27;, &#x27;data&#x27;, function (tpl, data) { // or ep.all([&#x27;
tpl&#x27;, &#x27;data&#x27;], function (tpl, data) {})
  // 在所有指定的事件触发后，将会被调用执行
  // 参数对应各自的事件名
});
fs.readFile(&#x27;template.tpl&#x27;, &#x27;utf-8&#x27;, function (err, content) {
  ep.emit(&#x27;tpl&#x27;, content);
});
db.get(&#x27;some sql&#x27;, function (err, result) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.any" id="apidoc.element.eventproxy.EventProxy.prototype.any">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>any
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">any = function () {
  var proxy = this,
    callback = arguments[arguments.length - 1],
    events = SLICE.call(arguments, 0, -1),
    _eventname = events.join(&#x22;_&#x22;);

  debug(&#x27;Add listenner for Any of events %j emit&#x27;, events);
  proxy.once(_eventname, callback);

  var _bind = function (key) {
    proxy.bind(key, function (data) {
      debug(&#x27;One of events %j emited, execute the listenner&#x27;);
      proxy.trigger(_eventname, {&#x22;data&#x22;: data, eventName: key});
    });
  };

  for (var index = 0; index &#x3c; events.length; index++) {
    _bind(events[index]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.asap" id="apidoc.element.eventproxy.EventProxy.prototype.asap">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>asap
        <span class="apidocSignatureSpan">(ev, callback, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asap = function (ev, callback, data) {
  this.bind(ev, callback);
  this.trigger(ev, data);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.assign" id="apidoc.element.eventproxy.EventProxy.prototype.assign">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>assign
        <span class="apidocSignatureSpan">(eventname1, eventname2, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assign = function (eventname1, eventname2, callback) {
  var args = CONCAT.apply([], arguments);
  args.push(true);
  _assign.apply(this, args);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * A module that can be mixed in to *any object* in order to provide it with custom events.
 * You may `bind` or `unbind` a callback function to an event;
 * `trigger`-ing an event fires all callbacks in succession.
 * Examples:
 * ```js
 * var render = function (template, resources) {};
 * var proxy = new EventProxy();
 * proxy.<span class="apidocCodeKeywordSpan">assign</span>(&#x22;template&#x22;, &#x22;l10n&#x22;, render);
 * proxy.trigger(&#x22;template&#x22;, template);
 * proxy.trigger(&#x22;l10n&#x22;, resources);
 * ```
 */
var EventProxy = function () {
  if (!(this instanceof EventProxy)) {
    return new EventProxy();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.assignAll" id="apidoc.element.eventproxy.EventProxy.prototype.assignAll">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>assignAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assignAll = function () {
  var args = CONCAT.apply([], arguments);
  args.push(false);
  _assign.apply(this, args);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.assignAlways" id="apidoc.element.eventproxy.EventProxy.prototype.assignAlways">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>assignAlways
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assignAlways = function () {
  var args = CONCAT.apply([], arguments);
  args.push(false);
  _assign.apply(this, args);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.bind" id="apidoc.element.eventproxy.EventProxy.prototype.bind">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>bind
        <span class="apidocSignatureSpan">(ev, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bind = function (ev, callback) {
  debug(&#x27;Add listener for %s&#x27;, ev);
  this._callbacks[ev] = this._callbacks[ev] || [];
  this._callbacks[ev].push(callback);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // 成功回调
  callback(null, {
    template: tpl,
    data: data
  });
});
// 侦听error事件
ep.<span class="apidocCodeKeywordSpan">bind</span>(&#x27;error&#x27;, function (err) {
  // 卸载掉所有handler
  ep.unbind();
  // 异常回调
  callback(err);
});
fs.readFile(&#x27;template.tpl&#x27;, &#x27;utf-8&#x27;, function (err, content) {
  if (err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.bindForAll" id="apidoc.element.eventproxy.EventProxy.prototype.bindForAll">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>bindForAll
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bindForAll = function (callback) {
  this.bind(ALL_EVENT, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    if (isOnce) {
      proxy.unbindForAll(_all);
    }
    debug(&#x27;Events %j all emited with data %j&#x27;, events, data);
    callback.apply(null, data);
  };
  proxy.<span class="apidocCodeKeywordSpan">bindForAll</span>(_all);
};

/**
 * Assign some events, after all events were fired, the callback will be executed once.
 *
 * Examples:
 * ```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.done" id="apidoc.element.eventproxy.EventProxy.prototype.done">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>done
        <span class="apidocSignatureSpan">(handler, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">done = function (handler, callback) {
  var that = this;
  return function (err, data) {
    if (err) {
      // put all arguments to the error handler
      return that.emit.apply(that, [&#x27;error&#x27;].concat(SLICE.call(arguments)));
    }

    // callback(err, args1, args2, ...)
    var args = SLICE.call(arguments, 1);

    if (typeof handler === &#x27;string&#x27;) {
      // getAsync(query, ep.done(&#x27;query&#x27;));
      // or
      // getAsync(query, ep.done(&#x27;query&#x27;, function (data) {
      //   return data.trim();
      // }));
      if (callback) {
        // only replace the args when it really return a result
        return that.emit(handler, callback.apply(null, args));
      } else {
        // put all arguments to the done handler
        //ep.done(&#x27;some&#x27;);
        //ep.on(&#x27;some&#x27;, function(args1, args2, ...){});
        return that.emit.apply(that, [handler].concat(args));
      }
    }

    // speed improve for mostly case: `callback(err, data)`
    if (arguments.length &#x3c;= 2) {
      return handler(data);
    }

    // callback(err, args1, args2, ...)
    handler.apply(null, args);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      template: tpl,
      data: data
    });
  });
  // 添加error handler
  ep.fail(callback);

  fs.readFile(&#x27;template.tpl&#x27;, &#x27;utf-8&#x27;, ep.<span class="apidocCodeKeywordSpan">done</span>(&#x27;tpl&#x27;));
  db.get(&#x27;some sql&#x27;, ep.done(&#x27;data&#x27;));
};
```

上述代码优化之后，业务开发者几乎不用关心异常处理了。代码量降低效果明显。
这里代码的转换，也许有开发者并不放心。其实秘诀在`fail`方法和`done`方法中。
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.doneLater" id="apidoc.element.eventproxy.EventProxy.prototype.doneLater">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>doneLater
        <span class="apidocSignatureSpan">(handler, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doneLater = function (handler, callback) {
  var _doneHandler = this.done(handler, callback);
  return function (err, data) {
    var args = arguments;
    later(function () {
      _doneHandler.apply(null, args);
    });
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```
上面代码中，我们把`db.check`的回调函数中的事件通过`emitLater`触发，这样,就算`db.check`的回调函数被同步执行了，事件的触发也还是异步的，`ep`在当前事件循环中监听了所有的事件，之后的事件循环中才会去触发`check`事件。代码顺序将和逻辑顺序保持一致。
当然，这么复杂的代码，必须可以像`ep.done()`一样通过`doneLater`来解决：

```js
var ep = EventProxy.create();

db.check(&#x27;key&#x27;, ep.<span class="apidocCodeKeywordSpan">doneLater</span>(&#x27;check&#x27;));

ep.once(&#x27;check&#x27;, function (permission) {
permission &#x26;&#x26; db.get(&#x27;key&#x27;, ep.done(&#x27;get&#x27;));
});

ep.once(&#x27;get&#x27;, function (data) {
render(data);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.emit" id="apidoc.element.eventproxy.EventProxy.prototype.emit">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>emit
        <span class="apidocSignatureSpan">(eventname, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function (eventname, data) {
  var list, ev, callback, i, l;
  var both = 2;
  var calls = this._callbacks;
  debug(&#x27;Emit event %s with data %j&#x27;, eventname, data);
  while (both--) {
    ev = both ? eventname : ALL_EVENT;
    list = calls[ev];
    if (list) {
      for (i = 0, l = list.length; i &#x3c; l; i++) {
        if (!(callback = list[i])) {
          list.splice(i, 1);
          i--;
          l--;
        } else {
          var args = [];
          var start = both ? 1 : 0;
          for (var j = start; j &#x3c; arguments.length; j++) {
            args.push(arguments[j]);
          }
          callback.apply(this, args);
        }
      }
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var ep = EventProxy.create(&#x22;template&#x22;, &#x22;data&#x22;, &#x22;l10n&#x22;, function (template, data, l10n) {
_.template(template, data, l10n);
});

$.get(&#x22;template&#x22;, function (template) {
// something
ep.<span class="apidocCodeKeywordSpan">emit</span>(&#x22;template&#x22;, template);
});
$.get(&#x22;data&#x22;, function (data) {
// something
ep.emit(&#x22;data&#x22;, data);
});
$.get(&#x22;l10n&#x22;, function (l10n) {
// something
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.emitLater" id="apidoc.element.eventproxy.EventProxy.prototype.emitLater">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>emitLater
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emitLater = function () {
  var self = this;
  var args = arguments;
  later(function () {
    self.trigger.apply(self, args);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
这时候，我们需要的就是 __异步事件触发__：

```js
var ep = EventProxy.create();

db.check(&#x27;key&#x27;, function (err, permission) {
if (err) {
  return ep.<span class="apidocCodeKeywordSpan">emitLater</span>(&#x27;error&#x27;, err);
}
ep.emitLater(&#x27;check&#x27;, permission);
});

ep.once(&#x27;check&#x27;, function (permission) {
permission &#x26;&#x26; db.get(&#x27;key&#x27;, function (err, data) {
  if (err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.fail" id="apidoc.element.eventproxy.EventProxy.prototype.fail">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>fail
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fail = function (callback) {
  var that = this;

  that.once(&#x27;error&#x27;, function () {
    that.unbind();
    // put all arguments to the error handler
    // fail(function(err, args1, args2, ...){})
    callback.apply(null, arguments);
  });
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // 成功回调
    callback(null, {
      template: tpl,
      data: data
    });
  });
  // 添加error handler
  ep.<span class="apidocCodeKeywordSpan">fail</span>(callback);

  fs.readFile(&#x27;template.tpl&#x27;, &#x27;utf-8&#x27;, ep.done(&#x27;tpl&#x27;));
  db.get(&#x27;some sql&#x27;, ep.done(&#x27;data&#x27;));
};
```

上述代码优化之后，业务开发者几乎不用关心异常处理了。代码量降低效果明显。
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.fire" id="apidoc.element.eventproxy.EventProxy.prototype.fire">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>fire
        <span class="apidocSignatureSpan">(eventname, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fire = function (eventname, data) {
  var list, ev, callback, i, l;
  var both = 2;
  var calls = this._callbacks;
  debug(&#x27;Emit event %s with data %j&#x27;, eventname, data);
  while (both--) {
    ev = both ? eventname : ALL_EVENT;
    list = calls[ev];
    if (list) {
      for (i = 0, l = list.length; i &#x3c; l; i++) {
        if (!(callback = list[i])) {
          list.splice(i, 1);
          i--;
          l--;
        } else {
          var args = [];
          var start = both ? 1 : 0;
          for (var j = start; j &#x3c; arguments.length; j++) {
            args.push(arguments[j]);
          }
          callback.apply(this, args);
        }
      }
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.group" id="apidoc.element.eventproxy.EventProxy.prototype.group">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>group
        <span class="apidocSignatureSpan">(eventname, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">group = function (eventname, callback) {
  var that = this;
  var group = eventname + &#x27;_group&#x27;;
  var index = that._after[group].index;
  that._after[group].index++;
  return function (err, data) {
    if (err) {
      // put all arguments to the error handler
      return that.emit.apply(that, [&#x27;error&#x27;].concat(SLICE.call(arguments)));
    }
    that.emit(group, {
      index: index,
      // callback(err, args1, args2, ...)
      result: callback ? callback.apply(null, SLICE.call(arguments, 1)) : data
    });
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var ep = new EventProxy();
ep.after(&#x27;got_file&#x27;, files.length, function (list) {
  // 在所有文件的异步执行结束后将被执行
  // 所有文件的内容都存在list数组中，按顺序排列
});
for (var i = 0; i &#x3c; files.length; i++) {
  fs.readFile(files[i], &#x27;utf-8&#x27;, ep.<span class="apidocCodeKeywordSpan">group</span>(&#x27;got_file&#x27;));
}
```
`group`秉承`done`函数的设计，它包含异常的传递。同时它还隐含了对返回数据进行编号，在结束时，按顺序返回。

```js
ep.group(&#x27;got_file&#x27;);
// 约等价于
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.headbind" id="apidoc.element.eventproxy.EventProxy.prototype.headbind">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>headbind
        <span class="apidocSignatureSpan">(ev, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">headbind = function (ev, callback) {
  debug(&#x27;Add listener for %s&#x27;, ev);
  this._callbacks[ev] = this._callbacks[ev] || [];
  this._callbacks[ev].unshift(callback);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.immediate" id="apidoc.element.eventproxy.EventProxy.prototype.immediate">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>immediate
        <span class="apidocSignatureSpan">(ev, callback, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">immediate = function (ev, callback, data) {
  this.bind(ev, callback);
  this.trigger(ev, data);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.not" id="apidoc.element.eventproxy.EventProxy.prototype.not">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>not
        <span class="apidocSignatureSpan">(eventname, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">not = function (eventname, callback) {
  var proxy = this;
  debug(&#x27;Add listenner for not event %s&#x27;, eventname);
  proxy.bindForAll(function (name, data) {
    if (name !== eventname) {
      debug(&#x27;listenner execute of event %s emit, but not event %s.&#x27;, name, eventname);
      callback(data);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.on" id="apidoc.element.eventproxy.EventProxy.prototype.on">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>on
        <span class="apidocSignatureSpan">(ev, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (ev, callback) {
  debug(&#x27;Add listener for %s&#x27;, ev);
  this._callbacks[ev] = this._callbacks[ev] || [];
  this._callbacks[ev].push(callback);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ep.once(&#x27;get&#x27;, function (err, data) {
  if (err) {
    return ep.emit(&#x27;error&#x27;, err);
  }
  render(data);
});

ep.<span class="apidocCodeKeywordSpan">on</span>(&#x27;error&#x27;, errorHandler);
```

没错，万一`db.check`的`callback`被同步执行了，在`ep`监听`check`事件之前，它就已经被抛出来了，后续逻辑没办法继续执行。尽管node的约定是所有的`callback`都是需要异步返回的，但是如果这个方法是由第三方提供的，我们没有办法保证`
db.check`的`callback`一定会异步执行，所以我们的代码通常就变成了这样:

```js
var ep = EventProxy.create();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.once" id="apidoc.element.eventproxy.EventProxy.prototype.once">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>once
        <span class="apidocSignatureSpan">(ev, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function (ev, callback) {
  var self = this;
  var wrapper = function () {
    callback.apply(self, arguments);
    self.unbind(ev, wrapper);
  };
  this.bind(ev, wrapper);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
db.check(&#x27;key&#x27;, function (err, permission) {
  if (err) {
    return ep.emit(&#x27;error&#x27;, err);
  }
  ep.emit(&#x27;check&#x27;, permission);
});

ep.<span class="apidocCodeKeywordSpan">once</span>(&#x27;check&#x27;, function (permission) {
  permission &#x26;&#x26; db.get(&#x27;key&#x27;, function (err, data) {
    if (err) {
      return ep.emit(&#x27;error&#x27;);
    }
    ep.emit(&#x27;get&#x27;, data);
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.removeAllListeners" id="apidoc.element.eventproxy.EventProxy.prototype.removeAllListeners">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>removeAllListeners
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAllListeners = function (event) {
  return this.unbind(event);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.removeListener" id="apidoc.element.eventproxy.EventProxy.prototype.removeListener">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>removeListener
        <span class="apidocSignatureSpan">(eventname, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function (eventname, callback) {
  var calls = this._callbacks;
  if (!eventname) {
    debug(&#x27;Remove all listeners&#x27;);
    this._callbacks = {};
  } else {
    if (!callback) {
      debug(&#x27;Remove all listeners of %s&#x27;, eventname);
      calls[eventname] = [];
    } else {
      var list = calls[eventname];
      if (list) {
        var l = list.length;
        for (var i = 0; i &#x3c; l; i++) {
          if (callback === list[i]) {
            debug(&#x27;Remove a listener of %s&#x27;, eventname);
            list[i] = null;
          }
        }
      }
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.subscribe" id="apidoc.element.eventproxy.EventProxy.prototype.subscribe">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>subscribe
        <span class="apidocSignatureSpan">(ev, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribe = function (ev, callback) {
  debug(&#x27;Add listener for %s&#x27;, ev);
  this._callbacks[ev] = this._callbacks[ev] || [];
  this._callbacks[ev].push(callback);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.tail" id="apidoc.element.eventproxy.EventProxy.prototype.tail">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>tail
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tail = function () {
  var args = CONCAT.apply([], arguments);
  args.push(false);
  _assign.apply(this, args);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
`after`方法适合重复的操作，比如读取10个文件，调用5次数据库等。将handler注册到N次相同事件的触发上。达到指定的触发数，handler将会被调用执行，每次触发的数据，将会按触发顺序，存为数组作为参数传入。

### 持续型异步协作
此处以股票为例，数据和模板都是异步获取，但是数据会持续刷新，视图会需要重新刷新。

```js
var ep = new EventProxy();
ep.<span class="apidocCodeKeywordSpan">tail</span>(&#x27;tpl&#x27;, &#x27;data&#x27;, function (tpl, data) {
  // 在所有指定的事件触发后，将会被调用执行
  // 参数对应各自的事件名的最新数据
});
fs.readFile(&#x27;template.tpl&#x27;, &#x27;utf-8&#x27;, function (err, content) {
  ep.emit(&#x27;tpl&#x27;, content);
});
setInterval(function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.throw" id="apidoc.element.eventproxy.EventProxy.prototype.throw">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>throw
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throw = function () {
  var that = this;
  that.emit.apply(that, [&#x27;error&#x27;].concat(SLICE.call(arguments)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### 神奇的 throw

`throw` 是 `ep.emit(&#x27;error&#x27;, err)` 的简写。

```js
var err = new Error();
ep.<span class="apidocCodeKeywordSpan">throw</span>(err);
// 实际是
ep.emit(&#x27;error&#x27;, err);
```

### 神奇的done

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.trigger" id="apidoc.element.eventproxy.EventProxy.prototype.trigger">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>trigger
        <span class="apidocSignatureSpan">(eventname, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trigger = function (eventname, data) {
  var list, ev, callback, i, l;
  var both = 2;
  var calls = this._callbacks;
  debug(&#x27;Emit event %s with data %j&#x27;, eventname, data);
  while (both--) {
    ev = both ? eventname : ALL_EVENT;
    list = calls[ev];
    if (list) {
      for (i = 0, l = list.length; i &#x3c; l; i++) {
        if (!(callback = list[i])) {
          list.splice(i, 1);
          i--;
          l--;
        } else {
          var args = [];
          var start = both ? 1 : 0;
          for (var j = start; j &#x3c; arguments.length; j++) {
            args.push(arguments[j]);
          }
          callback.apply(this, args);
        }
      }
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * You may `bind` or `unbind` a callback function to an event;
 * `trigger`-ing an event fires all callbacks in succession.
 * Examples:
 * ```js
 * var render = function (template, resources) {};
 * var proxy = new EventProxy();
 * proxy.assign(&#x22;template&#x22;, &#x22;l10n&#x22;, render);
 * proxy.<span class="apidocCodeKeywordSpan">trigger</span>(&#x22;template&#x22;, template);
 * proxy.trigger(&#x22;l10n&#x22;, resources);
 * ```
 */
var EventProxy = function () {
  if (!(this instanceof EventProxy)) {
    return new EventProxy();
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.unbind" id="apidoc.element.eventproxy.EventProxy.prototype.unbind">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>unbind
        <span class="apidocSignatureSpan">(eventname, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unbind = function (eventname, callback) {
  var calls = this._callbacks;
  if (!eventname) {
    debug(&#x27;Remove all listeners&#x27;);
    this._callbacks = {};
  } else {
    if (!callback) {
      debug(&#x27;Remove all listeners of %s&#x27;, eventname);
      calls[eventname] = [];
    } else {
      var list = calls[eventname];
      if (list) {
        var l = list.length;
        for (var i = 0; i &#x3c; l; i++) {
          if (callback === list[i]) {
            debug(&#x27;Remove a listener of %s&#x27;, eventname);
            list[i] = null;
          }
        }
      }
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    template: tpl,
    data: data
  });
});
// 侦听error事件
ep.bind(&#x27;error&#x27;, function (err) {
  // 卸载掉所有handler
  ep.<span class="apidocCodeKeywordSpan">unbind</span>();
  // 异常回调
  callback(err);
});
fs.readFile(&#x27;template.tpl&#x27;, &#x27;utf-8&#x27;, function (err, content) {
  if (err) {
    // 一旦发生异常，一律交给error事件的handler处理
    return ep.emit(&#x27;error&#x27;, err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventproxy.EventProxy.prototype.unbindForAll" id="apidoc.element.eventproxy.EventProxy.prototype.unbindForAll">
        function <span class="apidocSignatureSpan">eventproxy.EventProxy.prototype.</span>unbindForAll
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unbindForAll = function (callback) {
  this.unbind(ALL_EVENT, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return;
    }
    var data = [];
    for (var index = 0; index &#x3c; length; index++) {
      data.push(proxy._fired[events[index]].data);
    }
    if (isOnce) {
      proxy.<span class="apidocCodeKeywordSpan">unbindForAll</span>(_all);
    }
    debug(&#x27;Events %j all emited with data %j&#x27;, events, data);
    callback.apply(null, data);
  };
  proxy.bindForAll(_all);
};
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
